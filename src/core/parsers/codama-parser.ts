/**
 * Uho â€” Codama IDL Parser
 *
 * Parses Codama/Kinobi-format IDLs into a normalized ParsedIDL representation.
 * Codama is a hybrid format: instructions may use Shank-style discriminants
 * or Anchor-style discriminator arrays.
 */

import type {
  CodamaIDL,
  ParsedIDL,
  ParsedField,
  ParsedAccount,
  ParsedInstruction,
} from '../types.js';
import {
  toSnakeCase,
  PRIMITIVE_TYPE_MAP,
  discriminantByteSize,
  computeInstructionDiscriminator,
} from '../idl-parser.js';

// =============================================================================
// Codama IDL Detection
// =============================================================================

/**
 * Detects whether a JSON object is a Codama-format IDL.
 * Codama IDLs are generated by the Codama/Kinobi toolchain and have a hybrid
 * structure: they may look like Shank (with discriminant) or Anchor (with
 * discriminator arrays), but are distinguished by metadata.origin === "codama"
 * or by having both `address`/`metadata.address` plus `discriminant` on instructions.
 */
export function isCodamaIDL(idl: any): idl is CodamaIDL {
  if (idl?.metadata?.origin === 'codama') return true;
  if (idl?.metadata?.origin === 'kinobi') return true;
  return false;
}

// =============================================================================
// Codama IDL Parsing
// =============================================================================

/**
 * Parses a Codama-format IDL into a normalized ParsedIDL.
 * Codama is a hybrid: instructions may use discriminant (like Shank) or
 * discriminator arrays (like Anchor). We handle both.
 */
export function parseCodamaIDL(idl: CodamaIDL): ParsedIDL {
  const programId = idl.address || idl.metadata?.address || '';
  const programName = toSnakeCase(idl.name);

  const instructions: ParsedInstruction[] = (idl.instructions ?? []).map((ix) => {
    let discBuf: Buffer;

    if (ix.discriminator && ix.discriminator.length > 0) {
      // Anchor-style byte array discriminator
      discBuf = Buffer.from(ix.discriminator);
    } else if (ix.discriminant) {
      // Shank-style discriminant value
      const discSize = discriminantByteSize(ix.discriminant.type);
      discBuf = Buffer.alloc(discSize);
      if (discSize === 1) discBuf.writeUInt8(ix.discriminant.value);
      else if (discSize === 2) discBuf.writeUInt16LE(ix.discriminant.value);
      else if (discSize === 4) discBuf.writeUInt32LE(ix.discriminant.value);
    } else {
      discBuf = computeInstructionDiscriminator(ix.name);
    }

    const args: ParsedField[] = (ix.args ?? []).map((arg) => {
      const typeStr = typeof arg.type === 'string' ? arg.type : 'unknown';
      const mapped = PRIMITIVE_TYPE_MAP[typeStr];
      return {
        name: toSnakeCase(arg.name),
        type: typeStr,
        sqlType: mapped?.sqlType ?? 'JSONB',
        nullable: mapped?.nullable ?? false,
      };
    });

    const accounts = (ix.accounts ?? []).map((a) => a.name);

    return {
      name: ix.name,
      discriminator: discBuf,
      accounts,
      args,
    };
  });

  const accounts: ParsedAccount[] = (idl.accounts ?? []).map((acc) => ({
    name: acc.name,
    discriminator: acc.discriminator?.length === 8
      ? Buffer.from(acc.discriminator)
      : Buffer.alloc(8),
  }));

  return {
    programId,
    programName,
    events: [],
    accounts,
    instructions,
  };
}
