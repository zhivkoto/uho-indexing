/**
 * Uho — Database Writer
 *
 * Writes decoded events to PostgreSQL tables generated by the schema generator.
 * Handles batch inserts, duplicate prevention via ON CONFLICT, and indexer state tracking.
 */

import type pg from 'pg';
import type { ParsedIDL, DecodedEvent, DecodedInstruction, IndexerState, ParsedEvent, ParsedInstruction } from '../core/types.js';
import { eventTableName, instructionTableName } from '../core/schema-generator.js';
import { toSnakeCase } from '../core/idl-parser.js';

// =============================================================================
// Event Writer
// =============================================================================

export class EventWriter {
  private pool: pg.Pool;
  private parsedIdl: ParsedIDL;
  private eventFieldMap: Map<string, string[]>;
  private instructionDefMap: Map<string, ParsedInstruction>;

  constructor(pool: pg.Pool, parsedIdl: ParsedIDL) {
    this.pool = pool;
    this.parsedIdl = parsedIdl;

    // Build a lookup map: eventName → ordered list of snake_case field names
    this.eventFieldMap = new Map();
    for (const event of parsedIdl.events) {
      this.eventFieldMap.set(
        event.name,
        event.fields.map((f) => f.name) // already snake_case from parser
      );
    }

    // Build a lookup map: instructionName → ParsedInstruction
    this.instructionDefMap = new Map();
    for (const ix of parsedIdl.instructions) {
      this.instructionDefMap.set(ix.name, ix);
    }
  }

  /**
   * Writes a batch of decoded events to their respective PostgreSQL tables.
   * Wraps the entire batch in a transaction for atomicity.
   * Returns the number of events successfully written.
   */
  async writeEvents(events: DecodedEvent[]): Promise<number> {
    if (events.length === 0) return 0;

    const client = await this.pool.connect();
    let written = 0;

    try {
      await client.query('BEGIN');

      for (const event of events) {
        const inserted = await this.insertEvent(client, event);
        if (inserted) written++;
      }

      await client.query('COMMIT');
    } catch (err) {
      await client.query('ROLLBACK');
      throw new Error(`Failed to write events batch: ${(err as Error).message}`);
    } finally {
      client.release();
    }

    return written;
  }

  /**
   * Writes a single decoded event to its PostgreSQL table.
   */
  async writeEvent(event: DecodedEvent): Promise<void> {
    return this.writeEvents([event]).then(() => undefined);
  }

  /**
   * Writes a batch of decoded instructions to their respective PostgreSQL tables.
   * Returns the number of instructions successfully written.
   */
  async writeInstructions(instructions: DecodedInstruction[]): Promise<number> {
    if (instructions.length === 0) return 0;

    const client = await this.pool.connect();
    let written = 0;

    try {
      await client.query('BEGIN');

      for (const ix of instructions) {
        const inserted = await this.insertInstruction(client, ix);
        if (inserted) written++;
      }

      await client.query('COMMIT');
    } catch (err) {
      await client.query('ROLLBACK');
      throw new Error(`Failed to write instructions batch: ${(err as Error).message}`);
    } finally {
      client.release();
    }

    return written;
  }

  /**
   * Inserts a single decoded instruction into its corresponding table.
   */
  private async insertInstruction(
    client: pg.PoolClient,
    ix: DecodedInstruction
  ): Promise<boolean> {
    const ixDef = this.instructionDefMap.get(ix.instructionName);
    if (!ixDef) {
      console.warn(`[Writer] Unknown instruction type: ${ix.instructionName}, skipping`);
      return false;
    }

    const tableName = instructionTableName(this.parsedIdl.programName, ix.instructionName);

    // Build column list: metadata + args + account pubkeys (quoted for reserved words)
    const argFieldNames = ixDef.args.map((a) => a.name);
    const accountColNames = ixDef.accounts.map((a) => toSnakeCase(a));

    const columns = [
      '"slot"',
      '"block_time"',
      '"tx_signature"',
      '"ix_index"',
      ...argFieldNames.map((n) => `"${n}"`),
      ...accountColNames.map((n) => `"${n}"`),
    ];

    const blockTimeValue = ix.blockTime
      ? new Date(ix.blockTime * 1000).toISOString()
      : null;

    const values: unknown[] = [
      ix.slot,
      blockTimeValue,
      ix.txSignature,
      ix.ixIndex,
    ];

    // Add arg values
    for (const argField of ixDef.args) {
      const value = ix.args[argField.name] ?? findFieldValue(ix.args, argField.name);
      if (value === undefined || value === null) {
        values.push(null);
      } else if (argField.sqlType === 'JSONB') {
        // JSONB columns need valid JSON — wrap primitives in JSON
        values.push(typeof value === 'object' ? JSON.stringify(value) : JSON.stringify(value));
      } else if (typeof value === 'object') {
        values.push(JSON.stringify(value));
      } else {
        values.push(value);
      }
    }

    // Add account pubkey values
    for (const accName of ixDef.accounts) {
      values.push(ix.accounts[accName] ?? 'unknown');
    }

    const placeholders = values.map((_, i) => `$${i + 1}`).join(', ');
    const sql = `INSERT INTO ${tableName} (${columns.join(', ')}) VALUES (${placeholders}) ON CONFLICT DO NOTHING`;

    const result = await client.query(sql, values);
    return (result.rowCount ?? 0) > 0;
  }

  /**
   * Updates the indexer state in the _uho_state table.
   * Uses INSERT ... ON CONFLICT (upsert) for atomic create-or-update.
   */
  async updateState(
    programId: string,
    state: Partial<IndexerState>
  ): Promise<void> {
    // Build dynamic SET clauses for the fields being updated
    const fields: { column: string; value: unknown }[] = [];

    if (state.lastSlot !== undefined) fields.push({ column: 'last_slot', value: state.lastSlot });
    if (state.lastSignature !== undefined) fields.push({ column: 'last_signature', value: state.lastSignature });
    if (state.eventsIndexed !== undefined) fields.push({ column: 'events_indexed', value: state.eventsIndexed });
    if (state.status !== undefined) fields.push({ column: 'status', value: state.status });
    if (state.startedAt !== undefined) fields.push({ column: 'started_at', value: state.startedAt });
    if (state.lastPollAt !== undefined) fields.push({ column: 'last_poll_at', value: state.lastPollAt });
    if (state.error !== undefined) fields.push({ column: 'error', value: state.error });

    // Always include program_id and program_name as base columns
    // Parameter numbering: $1 = program_id, $2 = program_name, $3.. = dynamic fields
    const dynamicColumns = fields.map((f) => f.column);
    const dynamicValues = fields.map((f) => f.value);

    const allColumns = ['program_id', 'program_name', ...dynamicColumns, 'updated_at'];
    const allValues = [programId, this.parsedIdl.programName, ...dynamicValues];
    const placeholders = allValues.map((_, i) => `$${i + 1}`);
    placeholders.push('NOW()'); // updated_at

    // Build SET clause for ON CONFLICT (excludes program_id and program_name)
    const setClauses = dynamicColumns.map(
      (col, i) => `${col} = $${i + 3}` // +3 because $1=program_id, $2=program_name
    );
    setClauses.push('updated_at = NOW()');

    const sql = `
      INSERT INTO _uho_state (${allColumns.join(', ')})
      VALUES (${placeholders.join(', ')})
      ON CONFLICT (program_id)
      DO UPDATE SET ${setClauses.join(', ')}
    `;

    await this.pool.query(sql, allValues);
  }

  /**
   * Retrieves the current indexer state for a program.
   */
  async getState(programId: string): Promise<IndexerState | null> {
    const result = await this.pool.query(
      'SELECT * FROM _uho_state WHERE program_id = $1',
      [programId]
    );

    if (result.rows.length === 0) return null;

    const row = result.rows[0];
    return {
      lastSlot: Number(row.last_slot),
      lastSignature: row.last_signature,
      eventsIndexed: Number(row.events_indexed),
      status: row.status as IndexerState['status'],
      startedAt: row.started_at ? new Date(row.started_at) : new Date(),
      lastPollAt: row.last_poll_at ? new Date(row.last_poll_at) : null,
      error: row.error ?? undefined,
    };
  }

  // ===========================================================================
  // Private Methods
  // ===========================================================================

  /**
   * Inserts a single event into its corresponding table.
   * Uses parameterized queries to prevent SQL injection.
   * Returns true if a row was actually inserted, false if it was a duplicate.
   */
  private async insertEvent(
    client: pg.PoolClient,
    event: DecodedEvent
  ): Promise<boolean> {
    const fieldNames = this.eventFieldMap.get(event.eventName);
    if (!fieldNames) {
      console.warn(`[Writer] Unknown event type: ${event.eventName}, skipping`);
      return false;
    }

    const tableName = eventTableName(this.parsedIdl.programName, event.eventName);

    // Build column list: metadata columns + IDL field columns (quoted for reserved words)
    const columns = [
      '"slot"',
      '"block_time"',
      '"tx_signature"',
      '"ix_index"',
      '"inner_ix_index"',
      ...fieldNames.map((n) => `"${n}"`),
    ];

    // Build values: convert block_time from unix timestamp to ISO string
    const blockTimeValue = event.blockTime
      ? new Date(event.blockTime * 1000).toISOString()
      : null;

    const values: unknown[] = [
      event.slot,
      blockTimeValue,
      event.txSignature,
      event.ixIndex,
      event.innerIxIndex,
    ];

    // Add IDL field values, mapping from camelCase event data keys to snake_case
    for (const fieldName of fieldNames) {
      // Find the original camelCase key in event.data
      const value = findFieldValue(event.data, fieldName);
      // Serialize objects/arrays to JSON for JSONB columns
      if (typeof value === 'object' && value !== null && !Buffer.isBuffer(value)) {
        values.push(JSON.stringify(value));
      } else {
        values.push(value ?? null);
      }
    }

    // Build parameterized INSERT with ON CONFLICT DO NOTHING for dedup
    const placeholders = values.map((_, i) => `$${i + 1}`).join(', ');
    const sql = `INSERT INTO ${tableName} (${columns.join(', ')}) VALUES (${placeholders}) ON CONFLICT DO NOTHING`;

    const result = await client.query(sql, values);
    // rowCount is 0 when the insert was skipped due to ON CONFLICT DO NOTHING
    return (result.rowCount ?? 0) > 0;
  }
}

// =============================================================================
// Utilities
// =============================================================================

/**
 * Finds a field value in the event data object.
 * Tries the snake_case name first, then converts back to camelCase to search.
 */
function findFieldValue(
  data: Record<string, unknown>,
  snakeCaseField: string
): unknown {
  // Direct match (if data already has snake_case keys)
  if (snakeCaseField in data) return data[snakeCaseField];

  // Convert snake_case back to camelCase for lookup
  const camelCase = snakeCaseField.replace(/_([a-z])/g, (_, c) => c.toUpperCase());
  if (camelCase in data) return data[camelCase];

  return undefined;
}
